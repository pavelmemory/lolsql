package generator

import (
	"github.com/less-leg/utils"
	"strings"
	"text/template"
)

var Package, _ = template.New("").Parse(`package {{.}}`)

var Imports, _ = template.New("").Parse(`
import (
{{range .}}
	{{.}}
{{end}}
)

var invalidImportProtector = utils.InvalidImportProtection

// This code was auto-generated by LOLSQL code-generation tool.
// Please do not modify it manually. All changes will be deleted after regeneration.
`)

// TODO: add error as return value where panic is used
var Scanner_struct, _ = template.New("").Parse(`
type holder struct {
	temporary       interface{}
	propagationFunc func(*{{.Package}}.{{.StructName}}, interface{})
}

func (this *holder) propagate(entity *{{.Package}}.{{.StructName}}) {
	this.propagationFunc(entity, this.temporary)
}

type scanner struct {
	sql        string
	parameters []interface{}
	holders    map[string]*holder
	fieldNames []string
}

func (this *scanner) InitPropagation(selects []types.FielderColumner) error {
	this.holders = make(map[string]*holder)

	for _, selectable := range selects {
		if _, found := this.holders[selectable.Column()]; found {
			return errors.New("Query string was built incorrectly: Duplicated select field: " + selectable.Field())
		}

		var h *holder
		switch selectable.Field() {
		{{$package := .Package}}{{$structName := .StructName}}{{range .Fields}}
		case "{{.FieldName}}":
			h = &holder{
				temporary:new({{.IsNullable}}{{.FieldType}}),
				propagationFunc:func(entity *{{$package}}.{{$structName}}, tmp interface{}) {
					entity.{{.FieldName}} = *(tmp.(*{{.IsNullable}}{{.FieldType}}))
				},
			}
		{{end}}
		default:
			return errors.New("Unexpected field in select statement: " + selectable.Field())
		}

		this.holders[selectable.Field()] = h
		this.fieldNames = append(this.fieldNames, selectable.Field())
	}
	return nil
}

func (this *scanner) temporaries() []interface{} {
	temporaries := make([]interface{}, 0, len(this.fieldNames))
	for _, fieldName := range this.fieldNames {
		if holder, found := this.holders[fieldName]; found {
			temporaries = append(temporaries, holder.temporary)
		} else {
			panic("Selection builder has error: Holder for field was not found: " + fieldName)
		}
	}
	return temporaries
}

func (this *scanner) Fetch() *{{.Package}}.{{.StructName}} {
	entity := new({{.Package}}.{{.StructName}})
	for _, fieldName := range this.fieldNames {
		if holder, found := this.holders[fieldName]; found {
			holder.propagate(entity)
		} else {
			panic("Selection builder has error: Holder for field was not found: " + fieldName)
		}
	}
	return entity
}

func (this *scanner) Scan(db *sql.DB) ([]*{{.Package}}.{{.StructName}}, error) {
	rows, err := db.Query(this.sql, this.parameters...)
	if err != nil {
		return nil, err
	}

	var fetched []*{{.Package}}.{{.StructName}}
	for rows.Next() {
		if err = rows.Scan(this.temporaries()...); err != nil {
			if errClose := rows.Close(); errClose != nil {
				return nil, fmt.Errorf("Cause: %s\nClose: %s", err.Error(), errClose.Error())
			}
			return nil, err
		}
		fetched = append(fetched, this.Fetch())
	}

	if err = rows.Err(); err != nil {
		return nil, err
	}

	if err = rows.Close(); err != nil {
		return nil, err
	}

	return fetched, nil
}
`)

var Lol_struct, _ = template.New("").Parse(`
type lol struct {
	selectColumns []types.FielderColumner
	whereInited   bool
	scanner       scanner
}

func (this *lol) Fetch(db *sql.DB) ([]*{{.Package}}.{{.StructName}}, error) {
	err := this.scanner.InitPropagation(this.selectColumns)
	if err != nil {
		return nil, err
	}
	this.scanner.sql = this.Render()
	return this.scanner.Scan(db)
}

func (this *lol) Render() string {
	if (len(this.selectColumns) == 0) {
		return "select {{index .TableNameToColumns 1}} from {{index .TableNameToColumns 0}}"
	}
	cols := make([]string, 0, len(this.selectColumns))
	for _, selectColumn := range this.selectColumns {
		cols = append(cols, selectColumn.Column())
	}
	return "select " + strings.Join(cols, ", ") + " from {{index .TableNameToColumns 0}}"
}

func (this *lol) Where(cond types.LolCondition) *lolWhere {
	if this.whereInited {
		panic("Invalid usage of WHERE statement: double usage not supported.")
	}
	this.whereInited = true
	return &lolWhere{retrieval:this, condition:cond}
}
`)

var Select_func, _ = template.New("").Parse(`
func Select(selects ...types.FielderColumner) *lol {
	if len(selects) < 1 {
		return &lol{selectColumns:SelectAllColumns}
	}
	return &lol{selectColumns:selects}
}
`)

var LolWhere_struct, _ = template.New("").Parse(`
type lolWhere struct {
	retrieval *lol
	condition types.LolCondition
	next      []types.LolCondition
}

func (this *lolWhere) Fetch(db *sql.DB) ([]*{{.Package}}.{{.StructName}}, error) {
	err := this.retrieval.scanner.InitPropagation(this.retrieval.selectColumns)
	if err != nil {
		return nil, err
	}
	this.retrieval.scanner.sql = this.Render()
	this.retrieval.scanner.parameters = this.parameters()
	return this.retrieval.scanner.Scan(db)
}

func (this *lolWhere) parameters() []interface{} {
	parameters := this.condition.Parameters()[:]
	for _, c := range this.next {
		parameters = append(parameters, c.Parameters()...)
	}
	return parameters
}

func (this *lolWhere) Render() string {
	if len(this.next) > 0 {
		conds := make([]string, 0, len(this.next))
		for _, cond := range this.next {
			conds = append(conds, cond.Render())
		}
		return this.retrieval.Render() + " where (" + this.condition.Render() + ") " + strings.Join(conds, " ")
	}
	return this.retrieval.Render() + " where " + this.condition.Render()
}

func (this *lolWhere) And(cond types.LolCondition) *lolWhere {
	this.next = append(this.next, types.NewAndCondition(cond))
	return this
}

func (this *lolWhere) Or(cond types.LolCondition) *lolWhere {
	this.next = append(this.next, types.NewOrCondition(cond))
	return this
}
`)

var ColumnStub_struct, _ = template.New("").Funcs(
	template.FuncMap{
		"Title":           strings.Title,
		"ToLower":         strings.ToLower,
		"DotToUnderscore": utils.DotToUnderscore}).Parse(`
{{range .}}
type {{index . 0 | ToLower | DotToUnderscore}}Stub struct {}
var {{index . 0 | ToLower | DotToUnderscore}}StubConst {{index . 0 | ToLower | DotToUnderscore}}Stub
func {{index . 0 | Title | DotToUnderscore}}() *{{index . 0 | ToLower | DotToUnderscore}}Stub {return &{{index . 0 | ToLower | DotToUnderscore}}StubConst}
func ({{index . 0 | ToLower | DotToUnderscore}}Stub) Column() string {return "{{index . 1}}"}
func ({{index . 0 | ToLower | DotToUnderscore}}Stub) Field() string {return "{{index . 0 }}"}
{{end}}

var SelectAllColumns = []types.FielderColumner{
{{range .}}&{{index . 0 | ToLower | DotToUnderscore}}StubConst, {{end}}
}
`)

var ConditionByField, _ = template.New("").Funcs(template.FuncMap{
	"Title":           strings.Title,
	"ToLower":         strings.ToLower,
	"DotToUnderscore": utils.DotToUnderscore}).Parse(`
func {{index .FieldToColumn 0 | Title}}Is(v0 {{.TypeName}}, vnext ...{{.TypeName}}) types.LolCondition {
	parameters := []interface{}{v0}
	for _, n := range vnext {
		parameters = append(parameters, n)
	}
	return types.NewLolCondition({{ToLower .Selector}}{{if .Selector}}_{{end}}{{index .FieldToColumn 0 | ToLower | DotToUnderscore}}StubConst, parameters, types.DefineConditionsAmount(1 + len(vnext)) | types.Equals)
}

func {{index .FieldToColumn 0 | Title}}IsNot(v0 {{.TypeName}}, vnext ...{{.TypeName}}) types.LolCondition {
	parameters := []interface{}{v0}
	for _, n := range vnext {
		parameters = append(parameters, n)
	}
	return types.NewLolCondition({{ToLower .Selector}}{{if .Selector}}_{{end}}{{index .FieldToColumn 0 | ToLower | DotToUnderscore}}StubConst, parameters, types.DefineConditionsAmount(1 + len(vnext)) | types.Not | types.Equals)
}

{{if .IsNullable}}
func {{index .FieldToColumn 0 | Title}}IsNull() types.LolCondition {
	return types.NewLolCondition({{ToLower .Selector}}{{if .Selector}}_{{end}}{{index .FieldToColumn 0 | ToLower | DotToUnderscore}}StubConst, nil, types.Equals | types.Null)
}

func {{index .FieldToColumn 0 | Title}}IsNotNull() types.LolCondition {
	return types.NewLolCondition({{ToLower .Selector}}{{if .Selector}}_{{end}}{{index .FieldToColumn 0 | ToLower | DotToUnderscore}}StubConst, nil, types.Not | types.Equals | types.Null)
}
{{end}}

{{if .Likable}}
func {{index .FieldToColumn 0 | Title}}Like(v0 {{.TypeName}}, vnext ...{{.TypeName}}) types.LolCondition {
	parameters := []interface{}{v0}
	for _, n := range vnext {
		parameters = append(parameters, n)
	}
	return types.NewLolCondition({{ToLower .Selector}}{{if .Selector}}_{{end}}{{index .FieldToColumn 0 | ToLower | DotToUnderscore}}StubConst, parameters, types.DefineConditionsAmount(1 + len(vnext)) | types.Like)
}

func {{index .FieldToColumn 0 | Title}}NotLike(v0 {{.TypeName}}, vnext ...{{.TypeName}}) types.LolCondition {
	parameters := []interface{}{v0}
	for _, n := range vnext {
		parameters = append(parameters, n)
	}
	return types.NewLolCondition({{ToLower .Selector}}{{if .Selector}}_{{end}}{{index .FieldToColumn 0 | ToLower | DotToUnderscore}}StubConst, parameters, types.DefineConditionsAmount(1 + len(vnext)) | types.Not | types.Like)
}
{{end}}
`)
