package generator

import (
	"text/template"
	"strings"
	"github.com/less-leg/utils"
)

type valueToStringFuncs map[string]ValueToStringFunc

func (this *valueToStringFuncs)Get(typeName string) ValueToStringFunc {
	if f, found := map[string]ValueToStringFunc(*this)[typeName]; found {
		return f
	} else {
		panic("Unsopported type for string convertion: " + typeName)
	}
}

type ValueToStringFunc struct {
	Start string
	End string
}

var ValueToStringFuncs = valueToStringFuncs(map[string]ValueToStringFunc{
	"int":   ValueToStringFunc{Start:"strconv.FormatInt(int64(", End:"), 10)"},
	"int8":  ValueToStringFunc{Start:"strconv.FormatInt(int64(", End:"), 10)"},
	"int16": ValueToStringFunc{Start:"strconv.FormatInt(int64(", End:"), 10)"},
	"int32": ValueToStringFunc{Start:"strconv.FormatInt(int64(", End:"), 10)"},
	"int64": ValueToStringFunc{Start:"strconv.FormatInt(", End:", 10)"},

	"float32": ValueToStringFunc{Start:"strconv.FormatFloat(float64(", End:"), 'f', -1, 32)"},
	"float64": ValueToStringFunc{Start:"strconv.FormatFloat(", End:", 'f', -1, 64)"},

	"string": ValueToStringFunc{Start:"utils.Quote(", End:")"},

	"time.Time": ValueToStringFunc{Start:`utils.Quote((`, End:`).Format("2006-01-02 15:04:05"))`},
})

var Package, _ = template.New("").Parse(`package {{.}}`)

var Imports, _ = template.New("").Parse(`
import (
{{range .}}
{{.}}
{{end}}
)
var invalidImportProtector = utils.InvalidImportProtection

// This code was auto-generated by LOLSQL code-generation tool.
// Please do not modify it manually. All changes will be deleted after regeneration.
`)

var Column_interface, _ = template.New("").Parse(`
type column interface {
	Column() string
}
`)

var Lol_struct, _ = template.New("").Parse(`
type lol struct {
	selectColumns []column
	whereInited   bool
}

func (this *lol) Render() string {
	if (len(this.selectColumns) == 0) {
		return "select {{index . 1}} from {{index . 0}}"
	}
	cols := make([]string, 0, len(this.selectColumns))
	for _, selectColumn := range this.selectColumns {
		cols = append(cols, selectColumn.Column())
	}
	return "select " + strings.Join(cols, ", ") + " from {{index . 0}}"
}

func (this *lol) Where(cond LolCondition) *lolWhere {
	if this.whereInited {
		panic("Invalid usage of WHERE statement: double usage not supported.")
	}
	this.whereInited = true
	return &lolWhere{retrieval:this, condition:cond}
}
`)

var Select_func, _ = template.New("").Parse(`
func Select(selects ...column) *lol {
	return &lol{selectColumns:selects}
}
`)

var LolWhere_struct, _ = template.New("").Parse(`
type lolWhere struct {
	retrieval *lol
	condition LolCondition
	next      []LolCondition
}

func (this *lolWhere) Render() string {
	if len(this.next) > 0 {
		conds := make([]string, 0, len(this.next))
		for _, cond := range this.next {
			conds = append(conds, cond.Render())
		}
		return this.retrieval.Render() + " where (" + this.condition.Render() + ") " + strings.Join(conds, " ")
	}
	return this.retrieval.Render() + " where " + this.condition.Render()
}

func (this *lolWhere) And(cond LolCondition) *lolWhere {
	if this.next == nil {
		this.next = make([]LolCondition, 0, 1)
	}
	this.next = append(this.next, &lolConditionAnd{condition: cond})
	return this
}

func (this *lolWhere) Or(cond LolCondition) *lolWhere {
	if this.next == nil {
		this.next = make([]LolCondition, 0, 1)
	}
	this.next = append(this.next, &lolConditionOr{condition: cond})
	return this
}
`)

var LolConditionAnd_struct, _ = template.New("").Parse(`
type lolConditionAnd struct {
	HasNext
	condition LolCondition
}

func (this *lolConditionAnd) render() string {
	return "and (" + this.condition.Render() + ")"
}

func (this *lolConditionAnd) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *lolConditionAnd) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *lolConditionAnd) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}
`)

var LolConditionOr_struct, _ = template.New("").Parse(`
type lolConditionOr struct {
	HasNext
	condition LolCondition
}

func (this *lolConditionOr) render() string {
	return "or (" + this.condition.Render() + ")"
}

func (this *lolConditionOr) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *lolConditionOr) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *lolConditionOr) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}
`)

var ColumnStub_struct, _ = template.New("").Funcs(
	template.FuncMap{
		"Title": strings.Title,
		"ToLower": strings.ToLower,
		"DotToUnderscore": utils.DotToUnderscore}).Parse(`
{{range .}}
type {{index . 0 | ToLower | DotToUnderscore}}Stub struct { column }
var {{index . 0 | ToLower | DotToUnderscore}}StubConst {{index . 0 | ToLower | DotToUnderscore}}Stub
func {{index . 0 | Title | DotToUnderscore}}() *{{index . 0 | ToLower | DotToUnderscore}}Stub {return &{{index . 0 | ToLower | DotToUnderscore}}StubConst}
func (*{{index . 0 | ToLower | DotToUnderscore}}Stub) Column() string {return "{{index . 1}}"}
{{end}}
`)

var ConditionByField, _ = template.New("").Funcs(template.FuncMap{
	"Title": strings.Title,
	"ToLower": strings.ToLower,}).Parse(`
type {{index .FieldToColumn 0 | ToLower}}{{Title .StructName}} struct {
	HasNext
	values   []{{.IsNullable}}{{.TypeName}}
	checkNot bool
}

func (this *{{index .FieldToColumn 0 | ToLower}}{{Title .StructName}}) render() string {
	{{if .IsNullable}}
	if this.values == nil || len(this.values) == 0 {
		if this.checkNot {
			return "{{index .FieldToColumn 1}} is not null"
		} else {
			return "{{index .FieldToColumn 1}} is null"
		}
	}
	{{end}}
	if (len(this.values) == 1) {
		if this.checkNot {
			return "{{index .FieldToColumn 1}} <> " + {{.ValueToStringFunc.Start}}{{.IsNullable}}this.values[0]{{.ValueToStringFunc.End}}
		} else {
			return "{{index .FieldToColumn 1}} = " + {{.ValueToStringFunc.Start}}{{.IsNullable}}this.values[0]{{.ValueToStringFunc.End}}
		}
	}
	vstr := make([]string, 0, len(this.values))
	for _, vptr := range this.values {
		{{if .IsNullable}}
		if vptr != nil {
			vstr = append(vstr, {{.ValueToStringFunc.Start}}{{.IsNullable}}vptr{{.ValueToStringFunc.End}})
		}
		{{else}}
			vstr = append(vstr, {{.ValueToStringFunc.Start}}vptr{{.ValueToStringFunc.End}})
		{{end}}
	}
	if this.checkNot {
		return "{{index .FieldToColumn 1}} not in (" + strings.Join(vstr, ", ") + ")"
	} else {
		return "{{index .FieldToColumn 1}} in (" + strings.Join(vstr, ", ") + ")"
	}
}

func (this *{{index .FieldToColumn 0 | ToLower}}{{Title .StructName}}) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *{{index .FieldToColumn 0 | ToLower}}{{Title .StructName}}) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *{{index .FieldToColumn 0 | ToLower}}{{Title .StructName}}) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}

{{if .IsNullable}}
func {{index .FieldToColumn 0 | Title}}Is(value ...{{.IsNullable}}{{.TypeName}}) LolCondition {
	return &{{index .FieldToColumn 0 | ToLower}}{{Title .StructName}}{values:value}
}

func {{index .FieldToColumn 0 | Title}}IsNot(values ...{{.IsNullable}}{{.TypeName}}) LolCondition {
	return &{{index .FieldToColumn 0 | ToLower}}{{Title .StructName}}{values:values, checkNot: true}
}
{{else}}
func {{index .FieldToColumn 0 | Title}}Is(v0 {{.TypeName}}, vnext ...{{.TypeName}}) LolCondition {
	return &{{index .FieldToColumn 0 | ToLower}}{{Title .StructName}}{values:append([]{{.TypeName}}{v0}, vnext...)}
}

func {{index .FieldToColumn 0 | Title}}IsNot(v0 {{.TypeName}}, vnext ...{{.TypeName}}) LolCondition {
	return &{{index .FieldToColumn 0 | ToLower}}{{Title .StructName}}{values:append([]{{.TypeName}}{v0}, vnext...), checkNot: true}
}
{{end}}
`)
