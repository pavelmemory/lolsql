package handsome
import (

. "github.com/less-leg/types"

"strings"

"github.com/less-leg/utils"

"time"

)
var invalidImportProtector = utils.InvalidImportProtection

// This code was auto-generated by LOLSQL code-generation tool.
// Please do not modify it manually. All changes will be deleted after regeneration.

type column interface {
	Column() string
}

type lol struct {
	selectColumns []column
	whereInited   bool
}

func (this *lol) Render() string {
	if (len(this.selectColumns) == 0) {
		return "select USER_LOGIN, SECRET, DateOfBirth, Salary from USER"
	}
	cols := make([]string, 0, len(this.selectColumns))
	for _, selectColumn := range this.selectColumns {
		cols = append(cols, selectColumn.Column())
	}
	return "select " + strings.Join(cols, ", ") + " from USER"
}

func (this *lol) Where(cond LolCondition) *lolWhere {
	if this.whereInited {
		panic("Invalid usage of WHERE statement: double usage not supported.")
	}
	this.whereInited = true
	return &lolWhere{retrieval:this, condition:cond}
}

func Select(selects ...column) *lol {
	return &lol{selectColumns:selects}
}

type lolWhere struct {
	retrieval *lol
	condition LolCondition
	next      []LolCondition
}

func (this *lolWhere) Render() string {
	if len(this.next) > 0 {
		conds := make([]string, 0, len(this.next))
		for _, cond := range this.next {
			conds = append(conds, cond.Render())
		}
		return this.retrieval.Render() + " where (" + this.condition.Render() + ") " + strings.Join(conds, " ")
	}
	return this.retrieval.Render() + " where " + this.condition.Render()
}

func (this *lolWhere) And(cond LolCondition) *lolWhere {
	if this.next == nil {
		this.next = make([]LolCondition, 0, 1)
	}
	this.next = append(this.next, &lolConditionAnd{LolCondition: cond})
	return this
}

func (this *lolWhere) Or(cond LolCondition) *lolWhere {
	if this.next == nil {
		this.next = make([]LolCondition, 0, 1)
	}
	this.next = append(this.next, &lolConditionOr{LolCondition: cond})
	return this
}

type lolConditionAnd struct {
	HasNext
	LolCondition
}

func (this *lolConditionAnd) render() string {
	return "and (" + this.LolCondition.Render() + ")"
}

func (this *lolConditionAnd) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *lolConditionAnd) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{LolCondition:cond})
	return this
}

func (this *lolConditionAnd) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{LolCondition:cond})
	return this
}

func (this *lolConditionAnd) Next() LolCondition {
	return this.HasNext.Next()
}

func (this *lolConditionAnd) SetNext(n LolCondition) {
	this.HasNext.SetNext(n)
}

type lolConditionOr struct {
	HasNext
	LolCondition
}

func (this *lolConditionOr) render() string {
	return "or (" + this.LolCondition.Render() + ")"
}

func (this *lolConditionOr) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *lolConditionOr) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{LolCondition:cond})
	return this
}

func (this *lolConditionOr) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{LolCondition:cond})
	return this
}

func (this *lolConditionOr) Next() LolCondition {
	return this.HasNext.Next()
}

func (this *lolConditionOr) SetNext(n LolCondition) {
	this.HasNext.SetNext(n)
}


type loginStub struct { column }
var loginStubConst loginStub
func Login() *loginStub {return &loginStubConst}
func (*loginStub) Column() string {return "USER_LOGIN"}

type passwordStub struct { column }
var passwordStubConst passwordStub
func Password() *passwordStub {return &passwordStubConst}
func (*passwordStub) Column() string {return "SECRET"}

type dateofbirthStub struct { column }
var dateofbirthStubConst dateofbirthStub
func DateOfBirth() *dateofbirthStub {return &dateofbirthStubConst}
func (*dateofbirthStub) Column() string {return "DateOfBirth"}

type salaryStub struct { column }
var salaryStubConst salaryStub
func Salary() *salaryStub {return &salaryStubConst}
func (*salaryStub) Column() string {return "Salary"}


type loginHandsome struct {
	loginStub
	HasNext
	values   []string
	operation ConditionConstant
}

func (this *loginHandsome) Values() []string {
	return this.values
}

func (this *loginHandsome) render() string {
	if conditionRendering, found := ConditionRenderingMap[this.operation]["string"]; found {
		return conditionRendering(this)
	}
	panic("Not supported operation for: string")
}

func (this *loginHandsome) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *loginHandsome) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{LolCondition:cond})
	return this
}

func (this *loginHandsome) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{LolCondition:cond})
	return this
}

func LoginIs(v0 string, vnext ...string) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]string, 0, 1 + counter)
	buf = append(buf, v0)
	return &loginHandsome{values:append(buf, vnext...), operation:amount | Equals}
}

func LoginIsNot(v0 string, vnext ...string) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]string, 0, 1 + counter)
	buf = append(buf, v0)
	return &loginHandsome{values:append(buf, vnext...), operation:amount | Not | Equals}
}


func LoginLike(v0 string, vnext ...string) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]string, 0, 1 + counter)
	buf = append(buf, v0)
	return &loginHandsome{values:append(buf, vnext...), operation:amount | Like}
}

func LoginNotLike(v0 string, vnext ...string) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]string, 0, 1 + counter)
	buf = append(buf, v0)
	return &loginHandsome{values:append(buf, vnext...), operation: amount | Not | Like}
}


type passwordHandsome struct {
	passwordStub
	HasNext
	values   []*int64
	operation ConditionConstant
}

func (this *passwordHandsome) Values() []*int64 {
	return this.values
}

func (this *passwordHandsome) render() string {
	if conditionRendering, found := ConditionRenderingMap[this.operation]["*int64"]; found {
		return conditionRendering(this)
	}
	panic("Not supported operation for: int64")
}

func (this *passwordHandsome) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *passwordHandsome) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{LolCondition:cond})
	return this
}

func (this *passwordHandsome) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{LolCondition:cond})
	return this
}

func PasswordIs(v0 *int64, vnext ...*int64) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]*int64, 0, 1 + counter)
	buf = append(buf, v0)
	return &passwordHandsome{values:append(buf, vnext...), operation:amount | Equals}
}

func PasswordIsNot(v0 *int64, vnext ...*int64) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]*int64, 0, 1 + counter)
	buf = append(buf, v0)
	return &passwordHandsome{values:append(buf, vnext...), operation:amount | Not | Equals}
}



type dateofbirthHandsome struct {
	dateofbirthStub
	HasNext
	values   []*time.Time
	operation ConditionConstant
}

func (this *dateofbirthHandsome) Values() []*time.Time {
	return this.values
}

func (this *dateofbirthHandsome) render() string {
	if conditionRendering, found := ConditionRenderingMap[this.operation]["*time.Time"]; found {
		return conditionRendering(this)
	}
	panic("Not supported operation for: time.Time")
}

func (this *dateofbirthHandsome) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *dateofbirthHandsome) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{LolCondition:cond})
	return this
}

func (this *dateofbirthHandsome) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{LolCondition:cond})
	return this
}

func DateOfBirthIs(v0 *time.Time, vnext ...*time.Time) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]*time.Time, 0, 1 + counter)
	buf = append(buf, v0)
	return &dateofbirthHandsome{values:append(buf, vnext...), operation:amount | Equals}
}

func DateOfBirthIsNot(v0 *time.Time, vnext ...*time.Time) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]*time.Time, 0, 1 + counter)
	buf = append(buf, v0)
	return &dateofbirthHandsome{values:append(buf, vnext...), operation:amount | Not | Equals}
}



type salaryHandsome struct {
	salaryStub
	HasNext
	values   []float32
	operation ConditionConstant
}

func (this *salaryHandsome) Values() []float32 {
	return this.values
}

func (this *salaryHandsome) render() string {
	if conditionRendering, found := ConditionRenderingMap[this.operation]["float32"]; found {
		return conditionRendering(this)
	}
	panic("Not supported operation for: float32")
}

func (this *salaryHandsome) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *salaryHandsome) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{LolCondition:cond})
	return this
}

func (this *salaryHandsome) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{LolCondition:cond})
	return this
}

func SalaryIs(v0 float32, vnext ...float32) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]float32, 0, 1 + counter)
	buf = append(buf, v0)
	return &salaryHandsome{values:append(buf, vnext...), operation:amount | Equals}
}

func SalaryIsNot(v0 float32, vnext ...float32) LolCondition {
	amount := Single
	counter := len(vnext)
	if counter > 0 {
		amount = Multi
	}
	buf := make([]float32, 0, 1 + counter)
	buf = append(buf, v0)
	return &salaryHandsome{values:append(buf, vnext...), operation:amount | Not | Equals}
}


