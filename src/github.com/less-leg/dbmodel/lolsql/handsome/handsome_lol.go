package handsome
import (

. "github.com/less-leg/types"

"strings"

"strconv"

"github.com/less-leg/utils"

"time"

)
var invalidImportProtector = utils.InvalidImportProtection

// This code was auto-generated by LOLSQL code-generation tool.
// Please do not modify it manually. All changes will be deleted after regeneration.

type column interface {
	Column() string
}

type lol struct {
	selectColumns []column
	whereInited   bool
}

func (this *lol) Render() string {
	if (len(this.selectColumns) == 0) {
		return "select USER_LOGIN, SECRET, DateOfBirth, Salary from USER"
	}
	cols := make([]string, 0, len(this.selectColumns))
	for _, selectColumn := range this.selectColumns {
		cols = append(cols, selectColumn.Column())
	}
	return "select " + strings.Join(cols, ", ") + " from USER"
}

func (this *lol) Where(cond LolCondition) *lolWhere {
	if this.whereInited {
		panic("Invalid usage of WHERE statement: double usage not supported.")
	}
	this.whereInited = true
	return &lolWhere{retrieval:this, condition:cond}
}

func Select(selects ...column) *lol {
	return &lol{selectColumns:selects}
}

type lolWhere struct {
	retrieval *lol
	condition LolCondition
	next      []LolCondition
}

func (this *lolWhere) Render() string {
	if len(this.next) > 0 {
		conds := make([]string, 0, len(this.next))
		for _, cond := range this.next {
			conds = append(conds, cond.Render())
		}
		return this.retrieval.Render() + " where (" + this.condition.Render() + ") " + strings.Join(conds, " ")
	}
	return this.retrieval.Render() + " where " + this.condition.Render()
}

func (this *lolWhere) And(cond LolCondition) *lolWhere {
	if this.next == nil {
		this.next = make([]LolCondition, 0, 1)
	}
	this.next = append(this.next, &lolConditionAnd{condition: cond})
	return this
}

func (this *lolWhere) Or(cond LolCondition) *lolWhere {
	if this.next == nil {
		this.next = make([]LolCondition, 0, 1)
	}
	this.next = append(this.next, &lolConditionOr{condition: cond})
	return this
}

type lolConditionAnd struct {
	HasNext
	condition LolCondition
}

func (this *lolConditionAnd) render() string {
	return "and (" + this.condition.Render() + ")"
}

func (this *lolConditionAnd) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *lolConditionAnd) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *lolConditionAnd) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}

type lolConditionOr struct {
	HasNext
	condition LolCondition
}

func (this *lolConditionOr) render() string {
	return "or (" + this.condition.Render() + ")"
}

func (this *lolConditionOr) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *lolConditionOr) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *lolConditionOr) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}


type loginStub struct { column }
var loginStubConst loginStub
func Login() *loginStub {return &loginStubConst}
func (*loginStub) Column() string {return "USER_LOGIN"}

type passwordStub struct { column }
var passwordStubConst passwordStub
func Password() *passwordStub {return &passwordStubConst}
func (*passwordStub) Column() string {return "SECRET"}

type dateofbirthStub struct { column }
var dateofbirthStubConst dateofbirthStub
func DateOfBirth() *dateofbirthStub {return &dateofbirthStubConst}
func (*dateofbirthStub) Column() string {return "DateOfBirth"}

type salaryStub struct { column }
var salaryStubConst salaryStub
func Salary() *salaryStub {return &salaryStubConst}
func (*salaryStub) Column() string {return "Salary"}


type loginHandsome struct {
	HasNext
	values []string
	not    bool
	like   bool
}

const (
	_ = 1 << (10 * iota)
	Single
	Multi
	Not
	Like
	Equal
)
var comparisons = map[int]string {
	Single & Equal: "=",
	Single & Not & Equal: "<>",
	Single & Like: "like",
	Single & Not & Like: "not like",
}

func (this *loginHandsome) render() string {
	var comparison string
	multi := len(this.values) > 1
	switch {
	case len(this.values) == 0 && !this.not:
		comparison = "is"
	case len(this.values) == 0 && this.not:
		comparison = "is not"
	case multi && !this.not:
		comparison = "in"
	case multi && this.not:
		comparison = "not in"
	case !multi && this.not && this.like:
		comparison = "not like"
	case !multi && !this.not && this.like:
		comparison = "like"
	case !multi && this.not && !this.like:
		comparison = "<>"
	case !multi && !this.not && !this.like:
		comparison = "="
	}

	value := "null"
	switch len(this.values) {
	case 0:
	case 1:
		value = utils.Quote(this.values[0])
	default:
		vstr := make([]string, 0, len(this.values))
		for _, vptr := range this.values {
			vstr = append(vstr, utils.Quote(vptr))
		}
		value = " (" + strings.Join(vstr, ", ") + ")"
	}
	return strings.Join([]string{"USER_LOGIN", comparison, value}, " ")
}

func (this *loginHandsome) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *loginHandsome) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *loginHandsome) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}


func LoginIs(v0 string, vnext ...string) LolCondition {
	return &loginHandsome{values:append([]string{v0}, vnext...)}
}

func LoginIsNot(v0 string, vnext ...string) LolCondition {
	return &loginHandsome{values:append([]string{v0}, vnext...), not:true}
}

func LoginLike(v0 string, vnext ...string) LolCondition {
	return &loginHandsome{values:append([]string{v0}, vnext...), like:true}
}

func LoginNotLike(v0 string, vnext ...string) LolCondition {
	return &loginHandsome{values:append([]string{v0}, vnext...), like:true, not:true}
}

type passwordHandsome struct {
	HasNext
	values    []*int64
	checkNot bool
}

func (this *passwordHandsome) render() string {
	
	if this.values == nil || len(this.values) == 0 {
		if this.checkNot {
			return "SECRET is not null"
		} else {
			return "SECRET is null"
		}
	}
	
	if (len(this.values) == 1) {
		if this.checkNot {
			return "SECRET <> " + strconv.FormatInt(*this.values[0], 10)
		} else {
			return "SECRET = " + strconv.FormatInt(*this.values[0], 10)
		}
	}
	vstr := make([]string, 0, len(this.values))
	for _, vptr := range this.values {
		
		if vptr != nil {
			vstr = append(vstr, strconv.FormatInt(*vptr, 10))
		}
		
	}
	if this.checkNot {
		return "SECRET not in (" + strings.Join(vstr, ", ") + ")"
	} else {
		return "SECRET in (" + strings.Join(vstr, ", ") + ")"
	}
}

func (this *passwordHandsome) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *passwordHandsome) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *passwordHandsome) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}


func PasswordIs(value ...*int64) LolCondition {
	return &passwordHandsome{values:value}
}

func PasswordIsNot(values ...*int64) LolCondition {
	return &passwordHandsome{values:values, checkNot: true}
}


type dateofbirthHandsome struct {
	HasNext
	values    []*time.Time
	checkNot bool
}

func (this *dateofbirthHandsome) render() string {
	
	if this.values == nil || len(this.values) == 0 {
		if this.checkNot {
			return "DateOfBirth is not null"
		} else {
			return "DateOfBirth is null"
		}
	}
	
	if (len(this.values) == 1) {
		if this.checkNot {
			return "DateOfBirth <> " + utils.Quote((*this.values[0]).Format("2006-01-02 15:04:05"))
		} else {
			return "DateOfBirth = " + utils.Quote((*this.values[0]).Format("2006-01-02 15:04:05"))
		}
	}
	vstr := make([]string, 0, len(this.values))
	for _, vptr := range this.values {
		
		if vptr != nil {
			vstr = append(vstr, utils.Quote((*vptr).Format("2006-01-02 15:04:05")))
		}
		
	}
	if this.checkNot {
		return "DateOfBirth not in (" + strings.Join(vstr, ", ") + ")"
	} else {
		return "DateOfBirth in (" + strings.Join(vstr, ", ") + ")"
	}
}

func (this *dateofbirthHandsome) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *dateofbirthHandsome) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *dateofbirthHandsome) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}


func DateOfBirthIs(value ...*time.Time) LolCondition {
	return &dateofbirthHandsome{values:value}
}

func DateOfBirthIsNot(values ...*time.Time) LolCondition {
	return &dateofbirthHandsome{values:values, checkNot: true}
}


type salaryHandsome struct {
	HasNext
	values    []float32
	checkNot bool
}

func (this *salaryHandsome) render() string {
	
	if (len(this.values) == 1) {
		if this.checkNot {
			return "Salary <> " + strconv.FormatFloat(float64(this.values[0]), 'f', -1, 32)
		} else {
			return "Salary = " + strconv.FormatFloat(float64(this.values[0]), 'f', -1, 32)
		}
	}
	vstr := make([]string, 0, len(this.values))
	for _, vptr := range this.values {
		
			vstr = append(vstr, strconv.FormatFloat(float64(vptr), 'f', -1, 32))
		
	}
	if this.checkNot {
		return "Salary not in (" + strings.Join(vstr, ", ") + ")"
	} else {
		return "Salary in (" + strings.Join(vstr, ", ") + ")"
	}
}

func (this *salaryHandsome) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *salaryHandsome) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *salaryHandsome) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}


func SalaryIs(v0 float32, vnext ...float32) LolCondition {
	return &salaryHandsome{values:append([]float32{v0}, vnext...)}
}

func SalaryIsNot(v0 float32, vnext ...float32) LolCondition {
	return &salaryHandsome{values:append([]float32{v0}, vnext...), checkNot: true}
}

