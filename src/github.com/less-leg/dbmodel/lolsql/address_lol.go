package address
import (. "github.com/less-leg/types"
"strings")
// This code was auto-generated by LOLSQL code-generation tool.
// Please do not modify it manually. All changes will be deleted after regeneration.
type column interface {Column() string}
type lol struct {
	selectColumns []column
	whereInited   bool
}

func (this *lol) Render() string {
	if (len(this.selectColumns) == 0) {
		return "select Building, Block, Flat, ID, Street from CITY_ADDRESS"
	}
	cols := make([]string, 0, len(this.selectColumns))
	for _, selectColumn := range this.selectColumns {
		cols = append(cols, selectColumn.Column())
	}
	return "select " + strings.Join(cols, ", ") + " from CITY_ADDRESS"
}

func (this *lol) Where(cond LolCondition) *lolWhere {
	if this.whereInited {
		panic("Invalid usage of WHERE statement: double usage not supported.")
	}
	this.whereInited = true
	return &lolWhere{retrieval:this, condition:cond}
}

func Select(selects ...column) *lol {
	return &lol{selectColumns:selects}
}

type lolWhere struct {
	retrieval *lol
	condition LolCondition
	next      []LolCondition
}
func (this *lolWhere) Render() string {
	if len(this.next) > 0 {
		conds := make([]string, 0, len(this.next))
		for _, cond := range this.next {
			conds = append(conds, cond.Render())
		}
		return this.retrieval.Render() + " where (" + this.condition.Render() + ") " + strings.Join(conds, " ")
	}
	return this.retrieval.Render() + " where " + this.condition.Render()
}
func (this *lolWhere) And(cond LolCondition) *lolWhere {
	if this.next == nil {
		this.next = make([]LolCondition, 0, 1)
	}
	this.next = append(this.next, &lolConditionAnd{condition: cond})
	return this
}
func (this *lolWhere) Or(cond LolCondition) *lolWhere {
	if this.next == nil {
		this.next = make([]LolCondition, 0, 1)
	}
	this.next = append(this.next, &lolConditionOr{condition: cond})
	return this
}
type lolConditionAnd struct {
	HasNext
	condition LolCondition
}

func (this *lolConditionAnd) render() string {
	return "and (" + this.condition.Render() + ")"
}

func (this *lolConditionAnd) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}

func (this *lolConditionAnd) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}

func (this *lolConditionAnd) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}
type lolConditionOr struct {
	HasNext
	condition LolCondition
}
func (this *lolConditionOr) render() string {
	return "or (" + this.condition.Render() + ")"
}
func (this *lolConditionOr) Render() string {
	if this.Next() != nil {
		return this.render() + " " + this.Next().Render()
	}
	return this.render()
}
func (this *lolConditionOr) And(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionAnd{condition:cond})
	return this
}
func (this *lolConditionOr) Or(cond LolCondition) LolCondition {
	this.SetNext(&lolConditionOr{condition:cond})
	return this
}

type BlockStub struct { column }
var BlockStubConst BlockStub
func Block() *BlockStub {return &BlockStubConst}
func (*BlockStub) Column() string {return "Block"}

type FlatStub struct { column }
var FlatStubConst FlatStub
func Flat() *FlatStub {return &FlatStubConst}
func (*FlatStub) Column() string {return "Flat"}

type PersonStub struct { column }
var PersonStubConst PersonStub
func Person() *PersonStub {return &PersonStubConst}
func (*PersonStub) Column() string {return "Person"}

type IdentifierStub struct { column }
var IdentifierStubConst IdentifierStub
func Identifier() *IdentifierStub {return &IdentifierStubConst}
func (*IdentifierStub) Column() string {return "Identifier"}

type StreetStub struct { column }
var StreetStubConst StreetStub
func Street() *StreetStub {return &StreetStubConst}
func (*StreetStub) Column() string {return "Street"}

type BuildingStub struct { column }
var BuildingStubConst BuildingStub
func Building() *BuildingStub {return &BuildingStubConst}
func (*BuildingStub) Column() string {return "Building"}

